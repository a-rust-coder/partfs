/// The BIOS Parameter Block (BPB) is the first sector of the volume.
///
/// It indicates some important infos about the volume. Actually, some fields are part of the
/// Boot Sector (BS) and some others to the BPB. These structures are thecnically different,
/// but in practice it doesn't matter.
#[derive(Debug, Clone, Copy)]
pub struct BiosParameterBlock {
    /// Jump instruction to the boot code. Only the tow following forms are allowed:
    ///  - [ 0xEB, 0x??, 0x90 ]
    ///  - [ 0xE9, 0x??, 0x?? ]
    pub(in crate::filesystems::fat) jmp_boot: [u8; 3],

    /// OEM Name identifier. Can be any desired value. Part of the BS.
    pub(in crate::filesystems::fat) oem_name: [u8; 8],

    /// Count of bytes per sector. Must be one of 512, 1024, 2048, 4096.
    pub(in crate::filesystems::fat) bytes_per_sector: u16,

    /// Count of sectors per cluster. Must be a power of 2.
    pub(in crate::filesystems::fat) sectors_per_cluster: u8,

    /// Number of reserved sectors in the reserved region of the volume, starting at the first
    /// sector (the BPB) of the volume. Used to align the start of the data area to integral
    /// multiples of the cluster size.
    ///
    /// Must not be 0, can be any non-zero value.
    pub(in crate::filesystems::fat) reserved_sectors_count: u16,

    /// Number of FATs on the volume. 2 is recommended.
    pub(in crate::filesystems::fat) number_of_fats: u8,

    /// Contains the count of 32-byte directory entries in the root directory. Should always
    /// specify a count that when multiplied by 32 results in an even multiple of
    /// `bytes_per_sector`.
    pub(in crate::filesystems::fat) root_entries_count: u16,

    /// The 16-bit count of sectors on the volume. It includes the count of all sectors in all
    /// regions of the volume. It can be 0, if it's 0, then the `total_sectors_32` field contains
    /// the sectors count. It must be non-zero if the total sectors count is less than 0x10000.
    pub(in crate::filesystems::fat) total_sectors_16: u16,

    /// Legal values are 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF.
    pub(in crate::filesystems::fat) media: u8,

    /// Count of sectors occupied by one FAT.
    pub(in crate::filesystems::fat) fat_size: u16,

    /// Irrelevant on volumes without geometry.
    pub(in crate::filesystems::fat) sectors_per_track: u16,

    /// Irrelevant on volumes without geometry.
    pub(in crate::filesystems::fat) number_of_heads: u16,

    /// Count of sectors preceding the partition that contains this FAT volume.
    pub(in crate::filesystems::fat) hidden_sectors: u32,

    /// The 32-bit count of sectors on the volume. It includes the count of all sectors in all
    /// regions of the volume. It can be 0, if it's 0, then the `total_sectors_16` field contains
    /// the sectors count. It must be non-zero if the total sectors count is greater than 0x10000.
    pub(in crate::filesystems::fat) total_sectors_32: u32,

    /// Must be 0x00 or 0x80.
    pub(in crate::filesystems::fat) drive_number: u8,

    /// Must be 0.
    pub(in crate::filesystems::fat) reserved0: u8,

    /// BS field. Must be 0x29 if the following fields are present.
    pub(in crate::filesystems::fat) boot_signature: u8,

    /// BS field.Volume serial number. Should be generated by combining current time and date.
    pub(in crate::filesystems::fat) volume_id: u32,

    /// BS field. Volume label. Must match the 11-byte volume label recorded in the root
    /// directory. By default, should be "NO NAME    ".
    pub(in crate::filesystems::fat) volume_label: [u8; 11],

    /// BS field. Must be "FAT12   " or "FAT     ". Informational only, does not determine the
    /// FAT type.
    pub(in crate::filesystems::fat) fs_type: [u8; 8],

    /// BS field. Contains the boot code in case of bootable media.
    pub(in crate::filesystems::fat) boot_code: [u8; 448],

    /// Must be 0xAA55 (little endian)
    pub(in crate::filesystems::fat) signature: u16,
}

impl BiosParameterBlock {
    #[must_use]
    pub fn to_bytes(&self) -> [u8; 512] {
        let mut bytes = [0; 512];

        bytes[..3].copy_from_slice(&self.jmp_boot);
        bytes[3..11].copy_from_slice(&self.oem_name);
        bytes[11..13].copy_from_slice(&self.bytes_per_sector.to_le_bytes());
        bytes[13] = self.sectors_per_cluster;
        bytes[14..16].copy_from_slice(&self.reserved_sectors_count.to_le_bytes());
        bytes[16] = self.number_of_fats;
        bytes[17..19].copy_from_slice(&self.root_entries_count.to_le_bytes());
        bytes[19..21].copy_from_slice(&self.total_sectors_16.to_le_bytes());
        bytes[21] = self.media;
        bytes[22..24].copy_from_slice(&self.fat_size.to_le_bytes());
        bytes[24..26].copy_from_slice(&self.sectors_per_track.to_le_bytes());
        bytes[26..28].copy_from_slice(&self.number_of_heads.to_le_bytes());
        bytes[28..32].copy_from_slice(&self.hidden_sectors.to_le_bytes());
        bytes[32..36].copy_from_slice(&self.total_sectors_32.to_le_bytes());
        bytes[36] = self.drive_number;
        bytes[37] = self.reserved0;
        bytes[38] = self.boot_signature;
        bytes[39..43].copy_from_slice(&self.volume_id.to_le_bytes());
        bytes[43..54].copy_from_slice(&self.volume_label);
        bytes[54..62].copy_from_slice(&self.fs_type);
        bytes[62..510].copy_from_slice(&self.boot_code);
        bytes[510..].copy_from_slice(&self.signature.to_le_bytes());

        bytes
    }

    #[must_use]
    pub fn from_bytes(bytes: [u8; 512]) -> Self {
        // Should not panic
        #[allow(clippy::missing_panics_doc)]
        Self {
            jmp_boot: bytes[..3].try_into().unwrap(),
            oem_name: bytes[3..11].try_into().unwrap(),
            bytes_per_sector: u16::from_le_bytes([bytes[11], bytes[12]]),
            sectors_per_cluster: bytes[13],
            reserved_sectors_count: u16::from_le_bytes([bytes[14], bytes[15]]),
            number_of_fats: bytes[16],
            root_entries_count: u16::from_le_bytes([bytes[17], bytes[18]]),
            total_sectors_16: u16::from_le_bytes([bytes[19], bytes[20]]),
            media: bytes[21],
            fat_size: u16::from_le_bytes([bytes[22], bytes[23]]),
            sectors_per_track: u16::from_le_bytes([bytes[24], bytes[25]]),
            number_of_heads: u16::from_le_bytes([bytes[26], bytes[27]]),
            hidden_sectors: u32::from_le_bytes([bytes[28], bytes[29], bytes[30], bytes[31]]),
            total_sectors_32: u32::from_le_bytes([bytes[32], bytes[33], bytes[34], bytes[35]]),
            drive_number: bytes[36],
            reserved0: bytes[37],
            boot_signature: bytes[38],
            volume_id: u32::from_le_bytes([bytes[39], bytes[40], bytes[41], bytes[42]]),
            volume_label: bytes[43..54].try_into().unwrap(),
            fs_type: bytes[54..62].try_into().unwrap(),
            boot_code: bytes[62..510].try_into().unwrap(),
            signature: u16::from_le_bytes([bytes[510], bytes[511]]),
        }
    }

    #[must_use]
    pub const fn is_valid(&self) -> bool {
        self.bytes_per_sector >= 512
            && self.bytes_per_sector.is_power_of_two()
            && self.sectors_per_cluster.is_power_of_two()
            && self.reserved_sectors_count != 0
            && self.number_of_fats != 0
            && ((self.root_entries_count as usize) * 32)
                .is_multiple_of(self.bytes_per_sector as usize)
            && ((self.total_sectors_16 != 0 && self.total_sectors_32 == 0)
                || (self.total_sectors_32 >= 0x10000 && self.total_sectors_16 == 0))
            && self.media & 0xF0 == 0xF0
            && self.drive_number & !0x80 == 0
            && self.reserved0 == 0
            && self.fs_type[0] == b'F'
            && self.fs_type[1] == b'A'
            && self.fs_type[2] == b'T'
            && (self.fs_type[3] == b' ' || self.fs_type[3] == b'1')
            && (self.fs_type[4] == b' ' || self.fs_type[4] == b'2' || self.fs_type[4] == b'6')
            && self.fs_type[5] == b' '
            && self.fs_type[6] == b' '
            && self.fs_type[7] == b' '
            && self.signature == 0xAA55
    }

    #[must_use]
    pub const fn bytes_per_sector(&self) -> usize {
        self.bytes_per_sector as usize
    }

    #[must_use]
    pub const fn total_sectors(&self) -> usize {
        // This works only if the BPB is valid, if
        // total_sectors_16 = 0 <=> total_sectors_32 > 0x10000 and
        // total_sectors_16 > 0 <=> total_sectors_32 = 0
        (self.total_sectors_16 as usize) | (self.total_sectors_32 as usize)
    }

    #[must_use]
    pub const fn count_of_clusters(&self) -> usize {
        (((self.total_sectors_16 as usize) | (self.total_sectors_32 as usize))
            - (self.reserved_sectors_count as usize)
            - (self.number_of_fats as usize) * (self.fat_size as usize)
            - ((self.root_entries_count as usize) * 32) / (self.bytes_per_sector as usize))
            / (self.sectors_per_cluster as usize)
    }

    #[must_use]
    pub const fn reserved_sectors_count(&self) -> usize {
        self.reserved_sectors_count as usize
    }

    #[must_use]
    pub const fn number_of_fats(&self) -> usize {
        self.number_of_fats as usize
    }

    #[must_use]
    pub const fn fat_size(&self) -> usize {
        self.fat_size as usize
    }

    #[must_use]
    pub const fn sectors_per_cluster(&self) -> usize {
        self.sectors_per_cluster as usize
    }

    #[must_use]
    pub const fn root_entries_count(&self) -> usize {
        self.root_entries_count as usize
    }

    #[must_use]
    pub const fn data_start_sector(&self) -> usize {
        self.reserved_sectors_count()
            + self.fat_size() * self.number_of_fats()
            + ((self.root_entries_count as usize) * 32).div_ceil(self.bytes_per_sector())
    }
}
